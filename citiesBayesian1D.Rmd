---
title: "Bayesian Cities Model 1D"
author: "Dina Sinclair"
date: "June 9, 2018"
output: html_document
---

```{r, warning = FALSE, message = FALSE}
library("rstan")
```

### Inputs

##### Notation
Given

$$Y = (Y_1, \dots, Y_i) $$
where each $Y_i$ has its own given $\sigma_{i}$,assume $Y \sim N(\theta_i, \sigma_{i}^2)$.

We won't be looking at the individual data in any study, so we'll essentially be assuming that the sample size for every study $J = 1$. $Y_i$ is the *point estimation*, the mean of the study, and $\sigma_i$ is that study's variance. 

##### Arbitrary Example Inputs
For now, we'll use that classic arbitrary dataset I've been using
We'll hope that we can recover mu and tauSq correctly!
```{r}
# Set input parameters
set.seed(17)
mu <- 10
tauSq <- 2
I <- 3
J <- 1
sigmaSq <- c(0.1,0.4,.2)

# Calculate theta, reshape sigmaSq
theta <- rnorm(I, mu, tauSq)
sigmaSq <- matrix(sigmaSq, I , J)

# Calculate and reshape Y
Y_vect <- numeric()
for(i in 1:I){
  Y_vect <- c(Y_vect, rnorm(J,mean=theta[i],sd=sigmaSq[i,]))
}
Y <- matrix(Y_vect , I, J, byrow = TRUE)

# Save our input data together in a list
basic_dat_generated <- list(J,I,Y,sigmaSq)

# Display the generated input data for reference
print("Theta:")
theta
print("SigmaSq:")
sigmaSq
print("Y:")
Y
```

### Step 1: Calculate $\theta_i, \mu, \tau^2$ using the original priors Y

We're assuming a **random effects model**, that is that $$\theta_i \sim N(\mu, \tau^2) \text{ and } Y_i \sim N(\theta_i, \sigma_{i}^2)$$

To make use of this assumption, we need to estimate scalars $\mu$ and $\tau^2$ along with the vector $\theta = (\theta_1,\dots,\theta_N)$. We can do this using stan!

```{r}
fit <- stan(file = 'randomEffectsModelConstrainedI.stan', 
            data = basic_dat_generated, 
            iter = 1000, chains = 2)
fit
```


### Step 2: Pick $K$ studies to pilot, calculate $Y^P_k$

##### Theoretically

First, pick $K$ studies to update through new information. For these studies, we'll assume a **fixed effects model** and draw a new sample, imagining that this is a new study $Y^p_i$ done in the same place as study $Y_i$, so we can improve on our knowledge of $Y_i$. For now we will arbitrarily decide that $\sigma^P_{i} = \frac 1 5 \sigma_{i}$ (AKA that these new studies done will have a fifth of the error we were encountering in the first study). So for $i \in K$,

$$ Y^P_i \sim N(\theta_i, \frac 1 5 \sigma_{i})$$

##### Concretely

Here we're first going to go with the boring simple version where the subset K is just k=2. So we keep $Y_1$, $Y_3$ unchanged but need to make a $Y'_2$ using the generated $\theta_2$. We use an arbitrary 5x smaller sigma in $Y'_2$ than in $Y_2$ as noted in the norm above
```{r}
# Define set K of cities to try the pilot on and collect more data
K <- c(2)

# Calculate new data for all K new pilots
params <- extract(fit)
for (k in K){
  print("Theta for new pilot:")
  print(mean(params$theta[,k]))
  new_draw <- rnorm( J , mean = mean(params$theta[,k]) , sd = (1/5)*sigmaSq[k] )
  print("New Draw Results:")
  print(new_draw)
}
```

### Step 3: Update all $Y$ values to get $Y'$

Once those $k$ new values get calculated, update by combining to get 
$$update(Y_k, Y^P_k) = Y'_k$$

This draws on the idea that the mean can be combined with the equation
$$ \mu' = \frac{\mu_2 \sigma_1^2 + \sigma_2^2 \mu_1}{\sigma_2^2 + \sigma_1^2}$$
and variance can be combined using
$$\sigma' = \frac{\sigma_1^2 \sigma_2^2}{\sigma_1^2+\sigma_2^2} = \frac{1}{\frac{1}{\sigma_2^2}+\frac{1}{\sigma_1^2}}$$

##### Concretely 

Now that we have the generated new information $Y^P_k$, we need to combine it with the old information $Y_k$. We can do this by combining the means weighted by their standard deviations.

```{r}
update_Y <- function(mu1, mu2, sigSq1, sigSq2){
  update_mu <- (mu1*sigSq2 + mu2*sigSq1)/(sigSq1 + sigSq2)
  update_sigSq <- (sigSq1*sigSq2)/(sigSq1 + sigSq2)
  return(list(mu = update_mu, sigmaSq = update_sigSq))
}

# Calculate new data for all K new pilots
for (k in K){

  old_mean <- mean(params$theta[,k])
  old_sigmaSq <- sigmaSq[k]
  new_sigmaSq <- old_sigmaSq * (1/5)
  new_mean <- rnorm( 1 , mean = old_mean , sd = new_sigmaSq )
  Y_new <- update_Y(old_mean,new_mean,old_sigmaSq,new_sigmaSq)
  
  print("Theta chosen from new pilot:")
  print(old_mean)
  print("SigmaSq from original Y")
  print(old_sigmaSq)
  print("New Draw Result:")
  print(new_draw)
}
print("updated Y")
Y_new

```


### Step 4: Use $Y'$ to get final $\theta'$

and once we have all the updated $Y'_i$ we can use them to get $\theta'_i$ based off of $\mu', \tau'^{2}$ with $Y' \sim N(\theta'_i, \sigma'_{i})$ 

```{r, eval = FALSE}
updated_dat_generated <- list(J, I, Y_new, sigmaSq*(1/5))
fit_updated <- stan(file = 'randomEffectsModelConstrainedI.stan', 
            data = updated_dat_generated, 
            iter = 1000, chains = 2)
fit_updated
```





